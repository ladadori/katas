> NRZI код (Non Return to Zero Invertive) — один из способов линейного кодирования. Обладает двумя уровнями сигнала и используется для передачи битовых последовательностей, содержащих только 0 и 1. NRZI применяется, например, в оптических кабелях, где устойчиво распознаются только два состояния сигнала — свет и темнота.

### Принцип кодирования
При передаче логического нуля на вход кодирующего устройства передается потенциал, установленный на предыдущем такте (то есть состояние потенциала не меняется), а при передаче логической единицы потенциал инвертируется на противоположный.

![](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImU1YzNmNWY0MmExNmNmMTg5ODI5N2QzNTJjZDNiNzg0LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=d942c322ffef71b4866c76e60f9275af3abe75e73e940826f886f1840bcac4ba)

### solution.js
Реализуйте и экспортируйте по умолчанию функцию, которая принимает строку в виде графического представления линейного сигнала и возвращает строку с бинарным кодом. Внимательно изучите примеры.

Примеры:
```JavaScript
const signal1 = '_|¯|____|¯|__|¯¯¯';
nrzi(signal1); // '011000110100'
 
const signal2 = '|¯|___|¯¯¯¯¯|___|¯|_|¯';
nrzi(signal2); // '110010000100111'
 
const signal3 = '¯|___|¯¯¯¯¯|___|¯|_|¯';
nrzi(signal3); // '010010000100111'
 
const signal4 = '';
nrzi(signal4); // ''
 
const signal5 = '|';
nrzi(signal5); // ''
```

### Подсказки
Символ | в строке указывает на переключение сигнала и означает, что уровень сигнала в следующем такте будет изменён на противоположный по сравнению с предыдущим.

### Помощь зала
> @Anastasia Kvartalna
Если посмотреть внимательно на задание, то там после каждого символа `'|'` идет единица, то есть на этом моменте
`graph[index - 1] === '|' ? !start : start`
тебе не обязательно привязываться к переменой start, а сразу возвращать `? 1 : 0`
Еще, если посмотреть конвертированный из граф. схемы код из нулей и единиц, в нем символ `'|'` не выражается ни 0 ни 1, он просто указывает на переключение сигнала, соответственно, когда проходишь с помощью map по массиву, учитывай это, проверяй свой текущий элемент (signal)
`graph.map((signal, index) =>`
равен ли он `'|'`, если да, то можно просто вернуть пустую строку, и тогда после `join()` останутся 0 и 1
С первым элементом получается,  если он равен `'|'` возвращ. пустую строку, и тогда на след итерации, проверка посмотрит, что пред. был `'|'` и вернет 1
а если первый не `'|'`, то на проверке предыдущего (который будет undefined) вернет false, то есть логический 0

### Решение учителя

```JavaScript
export default (str) => str
  .split('')
  .map((e, i, arr) => {
    if (e === '|') return '';
    return arr[i - 1] === '|' ? 1 : 0;
  })
  .join('');
```